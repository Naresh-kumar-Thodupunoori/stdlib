'use strict';

// MODULES //

var tape = require( 'tape' );
var cunoneBy = require( './../lib' );

// TESTS //

tape( 'main export is a function', function test( t ) {
    t.ok( true, __filename );
    t.strictEqual( typeof cunoneBy, 'function', 'main export is a function' );
    t.end();
});

tape( 'attached to the main export is an assign method', function test( t ) {
    t.strictEqual( typeof cunoneBy.assign, 'function', 'has assign method' );
    t.end();
});

tape( 'the function throws an error if provided a first argument which is not an array-like object', function test( t ) {
    var values;
    var i;

    values = [
        '5',
        5,
        true,
        false,
        null,
        void 0,
        {},
        function noop() {}
    ];

    for ( i = 0; i < values.length; i++ ) {
        t.throws( badValue( values[i] ), TypeError, 'throws an error when provided '+values[i] );
    }
    t.end();

    function badValue( value ) {
        return function badValue() {
            cunoneBy( value, function() {} );
        };
    }
});

tape( 'the function throws an error if provided a second argument which is not a function', function test( t ) {
    var values;
    var i;

    values = [
        '5',
        5,
        true,
        false,
        null,
        void 0,
        {},
        []
    ];

    for ( i = 0; i < values.length; i++ ) {
        t.throws( badValue( values[i] ), TypeError, 'throws an error when provided '+values[i] );
    }
    t.end();

    function badValue( value ) {
        return function badValue() {
            cunoneBy( [1, 2, 3], value );
        };
    }
});

tape( 'the function returns an array', function test( t ) {
    var out = cunoneBy( [1, 2, 3], function() { return true; } );
    t.strictEqual( Array.isArray(out), true, 'returns an array' );
    t.end();
});

tape( 'the assign method throws an error if provided a first argument which is not an array-like object', function test( t ) {
    var values;
    var i;

    values = [
        '5',
        5,
        true,
        false,
        null,
        void 0,
        {},
        function noop() {}
    ];

    for ( i = 0; i < values.length; i++ ) {
        t.throws( badValue( values[i] ), TypeError, 'throws an error when provided '+values[i] );
    }
    t.end();

    function badValue( value ) {
        return function badValue() {
            cunoneBy.assign( value, [], 1, 0, function() {} );
        };
    }
});

// Add more tests as needed for the assign method and other aspects of the main export